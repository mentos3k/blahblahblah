<!DOCTYPE html>
<html>
<head>
  <title>Sandbox Aggressive PoC</title>
</head>
<body>
  <h2>🚩 Aggressive Sandbox PoC - For Defensive Logging Only</h2>
  <canvas id="glcanvas" width="1" height="1"></canvas>
  <pre id="log"></pre>

  <script>
    const log = msg => document.getElementById("log").textContent += msg + "\n";
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) {
      log("❌ WebGL2 not supported");
      throw new Error();
    }
    log("✅ WebGL2 acquired");

    // === FLOAT LEAK ===
    const vsSource = `#version 300 es
      in float a;
      out float b;
      void main() { b = a; gl_Position = vec4(0); }
    `;
    const fsSource = `#version 300 es
      precision mediump float;
      out vec4 outColor;
      void main() { outColor = vec4(1.0); }
    `;
    function compileShader(type, src) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      return s;
    }
    const prog = gl.createProgram();
    gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vsSource));
    gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fsSource));
    gl.transformFeedbackVaryings(prog, ['b'], gl.SEPARATE_ATTRIBS);
    gl.linkProgram(prog);
    gl.useProgram(prog);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([666.666]), gl.STATIC_DRAW);

    const loc = gl.getAttribLocation(prog, "a");
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 1, gl.FLOAT, false, 0, 0);

    const tfb = gl.createBuffer();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, tfb);
    gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, 4, gl.DYNAMIC_COPY);

    gl.enable(gl.RASTERIZER_DISCARD);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, 1);
    gl.endTransformFeedback();
    gl.disable(gl.RASTERIZER_DISCARD);

    const out = new Float32Array(1);
    gl.getBufferSubData(gl.TRANSFORM_FEEDBACK_BUFFER, 0, out);
    log(`📥 Read float: ${out[0]}`);

    // === AGGRESSIVE WASM SPRAY ===
    (async () => {
      log("🚀 Starting massive WASM spray...");
      const wasmModule = new Uint8Array([
        0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,
        0x01,0x04,0x01,0x60,0x00,0x00,
        0x03,0x02,0x01,0x00,
        0x07,0x07,0x01,0x03,0x66,0x6F,0x6F,0x00,0x00,
        0x0A,0x09,0x01,0x07,0x00,0x41,0x2A,0x41,0x2A,0x6A,0x0B
      ]);
      for (let i = 0; i < 5000; i++) {
        WebAssembly.instantiate(wasmModule).then(obj => {
          obj.instance.exports.foo();
        });
        if (i % 1000 === 0) log(`Sprayed ${i} modules`);
      }
      log("✅ WASM spraying done");
    })();

    // === INTENTIONAL HUGE ALLOCATION ===
    try {
      const bigArr = new ArrayBuffer(2 * 1024 * 1024 * 1024); // 2GB buffer
      log(`🗄️ Allocated huge buffer: ${bigArr.byteLength} bytes`);
    } catch (e) {
      log(`⚡ Allocation failed: ${e}`);
    }

    // === SIMULATE SANDBOX ESCAPE STAGE ===
    try {
      const fakeEvil = new Function("log('🔓 Trying to elevate privileges (simulated)')");
      fakeEvil();
    } catch (e) {
      log(`❌ Sandbox block: ${e}`);
    }

    // === INTENTIONAL CRASH ===
    setTimeout(() => {
      log("💥 Intentionally crashing renderer for logging test");
      const crash = new Array(1e10).join("A");
    }, 3000);
  </script>
</body>
</html>
